---
title: "EDA: water system boundary missingness, quality, & coverage"
output: 
  html_document:
    highlight: zenburn
    code_folding: hide
    toc: true
    # toc_float: true
    toc_depth: 3
    number_sections: true
    # css: etc/style/style.css
# bibliography: etc/references.bib  
# link-citations: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, out.width = "100%")

# datatable sytle
dt_make <- function(x){
  x %>% 
    DT::datatable(
    rownames = FALSE, 
    extensions = 'Buttons', 
    options = list(
      dom = 'Bfrtip', 
      buttons = c('copy', 'csv', 'excel')
    )
  )
}
```

*Jess Goddard & Rich Pauloo*

*Last updated `r Sys.time()`*

<br>  

# Introduction

Presently, approximately 55,700 active community water systems in the United States collectively serve tap water to approximately *318,000,000* people (source: SDWIS). These water systems cross-cut racial/ethnic, income, and political boundaries, yet despite their importance, up-to-date, easily accessible boundary data (i.e., spatial polygons that delineate water service boundaries) are not organized at the national level. State-level data may exist, but these data tend to be hard to find online, may require cleaning, and little is known on the completeness of these data nationwide. This is beginning to change. Organizations, businesses, and academics currently aim to fill the gaps. Insights about water quality challenges nationwide are stymied by a lack of water service area boundaries -- most research and work on water quality, for example, emphasizes county-level analyses. Moreover, funding for water systems under the new Justice40 Initiative require organized, accurate spatial data on community water systems and who they serve. 

The overarching goal of this [project](https://github.com/SimpleLab-Inc/wsb) is to assemble the nation's first open-source, reproducible pipeline to assimilate existing water service boundary data and provide estimated service boundaries where existing spatial data does not exist. Given large gaps in data, we will use a combination of data assimilation and machine learning to assign and predict proxy boundaries where formally labeled spatial data does not exist. To produce the national water service boundary layer, a variety of state and federal data sources must be cleaned, analyzed, joined, and ultimately, modeled. Underpinning this technical effort is a broader context of stakeholder communication and engagement, and data collection efforts to support modeling. 

This report provides an initial assessment of existing data sources to prepare for modeling and to facilitate the best allocation of resources in pursuit of a national boundary layer. In this report, we investigate data quality issues in state and federal data to:  

1. assess data "missingness" (e.g., missing water system boundary polygons, and `NA` or `NULL` values which will impact data collection efforts, and the ability to model missing data)  
2. examine data quality (e.g., do data actually represent what they report to represent?) to inform future data collection and cleaning efforts and to gauge the appropriateness of modeling with existing data  
3. review data coverage by various features of water systems (e.g., system size, system type, tribal designation, population served) to inform future data collection and cleaning efforts, and understand potential model limitations  

The work herein will be filed under an MIT License. Our motivation for doing this is the recognition that water data has historically been siloed within different state repositories, academic journals, or simply unavailable. We strive to break this boundary by encouraging an organized, open-source space where anyone can contribute and use the resultant data products.


<br>  

# Report outline

The following outline reflects an exploratory data analysis of the existing data, which can be expanded and re-run as new data sources are ingested:

_Missingness_  

- Existing coverage of spatial labeled data  
- Coverage and quality of centroids  
- Tabular data: assess missingness for key categories (i.e., population served, system size AKA connection count)  

_Data Quality_  

- Number of "imposter" centroids across datasets (echo, frs, mhp)  
- Appropriateness of TIGER/Line shapefile as proxy. Compare join for labeled systems: e.g., city of Davis, and Davis TIGER/Line places -> boolean T/F and jacard (less important)  

_Coverage relative to SDWIS master list of active, community water systems_  

- Summary of existing boundary coverage by system size (using [EPA categories](https://echo.epa.gov/help/drinking-water-dashboard-help))  
- Summary of existing boundary coverage by system type (Municipal, etc) / ownership type  
- Summary of existing boundary coverage by tribal vs non-tribal (i.e. primacy_type_code is territory?)  
- Total US population served by existing boundary date (using SDWIS provided `population_served`)  


<br>  

# Data Sources

Data Source  | Description  | Link|
------------- | ------------- | -------------|
EPA Safe Drinking Water Information Systems  | Public water systems "master list" with key attribute data and some tabular geographic data like cities served | [SDWIS MODEL](https://www.epa.gov/enviro/sdwis-model) |
EPA Enforcement and Compliance History Online| Public water system facilities archive, drawing lat/long data for facilities centroids from FRS | [ECHO Exporter](https://echo.epa.gov/tools/data-downloads#exporter)|
EPA Facilities Registry Service | FRS regularly updates facilities data with lat/long information, which pipes into ECHO | [FRS Geospatial](https://www.epa.gov/frs/geospatial-data-download-service) |
US Census Bureau TIGER/Line | US Census data of places--cities and towns--used to identify potential service area boundaries | [TIGER/Line Shapefiles](https://www.census.gov/geographies/mapping-files/time-series/geo/tiger-line-file.html) accessed using R package [tigris](https://www.rdocumentation.org/packages/tigris/versions/1.6) |
Labeled Water System Boundaries | URLs on state pages for various water service boundary sources| [State URL tracking doc](https://docs.google.com/spreadsheets/d/1ov0vx0A-qawxLwASHNRUIyXgJXhLjBHIQ4JxdhIyW4o/edit#gid=0) |

<br>  

# Missingness

We examine missingness of key datasets in terms of:

- **The existing coverage of "labeled" service boundaries.** "Labeled" service boundaries refer to spatial polygons of existing data and stand in contrast to "unlabeled" data, which are water systems _without_ explicit spatial polygons and for which we must estimate a boundary.  
- **Centroid coverage and quality.** For unlabeled data, we must estimate a boundary, and the model we will develop will estimate the radius of a water system boundary from a centroid. Thus we need spatial centroids for unlabeled data. Sometimes these centroids are provided, sometimes not. We assess their coverage nationwide and state-by-state.  
- **Tabular data missingness.** Tabular data is non-spatial data associated with water systems (e.g., population served, system size) that can be used to predict water system radii. Missingness or data quality issues in these columns may limit the extensibility of modeling and is thus characterized.  

<br>  

## Existing coverage of spatial labeled data


```{r}
library(tidyverse)
library(here)
library(fs)
library(sf)
library(mapview)
library(rcartocolor)
library(geofacet)

mapviewOptions(fgb = FALSE)

# data input location for EDA is the post-transformer staging path
staging_path <- Sys.getenv("WSB_STAGING_PATH")
epsg         <- as.numeric(Sys.getenv("WSB_EPSG"))

# # previously run to generate a small data file for plotting, then save
# wsb_labeled <- st_read(path(staging_path, "wsb_labeled.geojson")) %>%
#   rmapshaper::ms_simplify()
# dir_create(here("etc"))
# write_rds(wsb_labeled, here("etc/wsb_labeled_simplified.rds"))

# load existing labeled data and simply it for viewing
wsb_labeled_simp <- read_rds(here("etc/wsb_labeled_simplified.rds"))
```

Labeled spatial data (i.e.,m spatial polygons present) are present for `r nrow(wsb_labeled_simp)` PWSIDs that cover `r length(unique(wsb_labeled_simp$state))` states: `r paste(unique(wsb_labeled_simp$state), collapse = ", ")`. Due to constraints on visualizing the large number of vertices in these polygon data, the map shown below provides a low-resolution version of the labeled data, with only ~5% of vertices, but analyses all use the high-resolution version.  

```{r, echo=FALSE}
wsb_labeled_simp %>% 
  select(pwsid, gis_name) %>% 
  mapview(layer.name = "labeled wsb")
```

Labeled data is always preferred to unlabeled data. The assimilation of labeled data from all states would replace the modeling stage of this study, which aims to estimate water service boundaries for unlabeled data in their absence. Thus, data collection efforts should be prioritized for missing states (below).  

```{r}
# summarise missing and present states in a dataframe
states_missing <- state.abb[!state.abb %in% unique(wsb_labeled_simp$state)]
states_present <- unique(wsb_labeled_simp$state)

states_df <- tibble(
  state_abbr = c(states_missing, states_present),
  status = c(rep("missing", length(states_missing)), 
             rep("present", length(states_present)))
)

# pull usa state geometries, project to input data CRS
usa <- USAboundaries::us_states(resolution = "low") %>% 
  st_transform(epsg) %>% 
  left_join(states_df) %>% 
  tigris::shift_geometry() %>% 
  # remove peurto rico
  filter(!is.na(status))

# map of missing states
ggplot() +
  geom_sf(data = usa, aes(fill = status), alpha = 0.5, color = "white") +
  scale_fill_carto_d(palette = "Pastel") +
  labs(fill = "") +
  theme_void() + 
  labs(title = "Labeled data coverage by state",
       subtitle = paste("Last updated:", Sys.Date()))

# data table with buttons to export table
states_df %>% 
  filter(!is.na(state_abbr)) %>% 
  arrange(status, state_abbr) %>% 
  dt_make()
```

> **RECCOMENDATION:** we should collect as many upstream labeled data sources from missing states which will increase the completeness of the overall labeled dataset and improve predicted boundaries.  

<br>  

## Centroid coverage


<br>  

### Centroid coverage at all PWSIDs

Two large datasets exist which contain centroid data for water systems - ECHO and FRS (see data sources table above for links). Preliminary investigation of these data sources indicated that ECHO is a maintained facilities archive that updates quarterly. Much of its spatial data- lat/long centroids- comes directly from FRS, which is a weekly-updated database. FRS maintains a geospatial database of facilities (by water system) with geolocated centroids, but does not approximate centroids for systems without provided lat/long data. ECHO, on the other hand, conducts a geocoding excerise to assign a centroid to all water systems. As such, ECHO is a superset of FRS data, thus ECHO centroid coverage is assessed. As stated before, in this analysis we only focus on active community water systems (CWS). 

```{r}
# j stands for joined data, read and rm rownumber column
j <- read_csv(path(staging_path, "matched_output.csv"), col_select = -1)
```

First, `r round((nrow(filter(j, is.na(echo_latitude) | is.na(echo_longitude))) / nrow(j))*100, 2)`% of pwsids (`r nrow(filter(j, is.na(echo_latitude) | is.na(echo_longitude)))` / `r nrow(j)` ) are missing either a longitude or latitude (i.e., the x or y coordinate is `NA`). 

For the remaining systems that are "complete" in the sense that they have a spatial centroid, we want to understand how accurate that centroid is. ECHO provides the spatial method used to calculate a centroid for each system. Most centroids are derived from the county centroid, address matching on a house number, or a zip code centroid. County- and state-level centroids are of little use as these data offer low to little indication of the true water system location. Any method that appears less then 5% of the time is lumped into "other", while a small portion of systems were not geocoded and thus the method is `NA`.

```{r}
# joined data that is "complete" in the sense that it has a lng/lat
jc <- filter(j, !is.na(echo_latitude) & !is.na(echo_longitude))

jc %>% 
  # anything that appears less then 5% of the time is lumped into "other"
  mutate(echo_geocode_method = fct_lump_prop(echo_geocode_method, 0.05)) %>%
  group_by(echo_geocode_method) %>% 
  summarise(n = n()) %>% 
  ungroup() %>% 
  mutate(
    p = n/sum(n),
    echo_geocode_method = case_when(
    echo_geocode_method == "ADDRESS MATCHING-HOUSE NUMBER" ~ "address match",
    echo_geocode_method == "INTERPOLATION-PHOTO"           ~ "interp photo",
    echo_geocode_method == "County Centroid"               ~ "centroid county",
    echo_geocode_method == "State Centroid"                ~ "centroid state",
    echo_geocode_method == "Zip Code Centroid"             ~ "centroid zip",
    echo_geocode_method == "Other"                         ~ "other",
    TRUE ~ NA_character_
  )) %>% 
  ggplot(aes(fct_reorder(echo_geocode_method, p), p, 
             fill = echo_geocode_method)) + 
  geom_col() + 
  coord_flip() +
  scale_fill_carto_d() +
  scale_y_continuous(limits = c(0, 1)) +
  theme_minimal() +
  theme(panel.grid.minor = element_blank()) +
  labs(x = "", y = "Count", title = "ECHO geocoding method", subtitle = "Each water system centroid is estimated according to the following methods.") +
  guides(fill = "none")
```

Centroid geocoding method varies by state. States primarily derive centroid from:

- county centroids (e.g., VT, NH, NY, SD, NJ, UT, CO, and so on - blue bars in plot below)  
- zipcode centroids (e.g., MT, MA, NV, CT, HI - green bars in plot below)
- interpolation photos (e.g., WA, ID, OR, AK - pink bars in plot below)  
- address (e.g., IA, IN, OH - orange bars in plot below)  


```{r}
# summary proportion of geocoding method by state
jcs <- jc %>% 
  # anything that appears less then 5% of the time is lumped into "other"
  mutate(echo_geocode_method = fct_lump_prop(echo_geocode_method, 0.05)) %>%
  group_by(primacy_agency_code, echo_geocode_method) %>% 
  summarise(n = n()) %>% 
  mutate(p = n / sum(n)) %>% 
  mutate(echo_geocode_method = case_when(
    echo_geocode_method == "ADDRESS MATCHING-HOUSE NUMBER" ~ "address match",
    echo_geocode_method == "INTERPOLATION-PHOTO"           ~ "interp photo",
    echo_geocode_method == "County Centroid"               ~ "centroid county",
    echo_geocode_method == "State Centroid"                ~ "centroid state",
    echo_geocode_method == "Zip Code Centroid"             ~ "centroid zip",
    echo_geocode_method == "Other"                         ~ "other",
    TRUE ~ NA_character_
  )) %>% 
  ungroup()
  
jcs %>% 
  filter(!is.na(primacy_agency_code)) %>% 
  ggplot(aes(fct_reorder(echo_geocode_method, p), p, 
             fill = echo_geocode_method)) + 
  geom_col() + 
  coord_flip() +
  scale_fill_carto_d() +
  scale_y_continuous(breaks = c(0, 0.5, 1),
                     labels = c(0, 0.5, 1),
                     limits = c(0, 1)) +
  geofacet::facet_geo(~primacy_agency_code) +
  labs(x = "", y = "Proportion", 
       title = "ECHO geocoding method by state") +
  guides(fill = "none") +
  theme_minimal(base_size = 6) +
  theme(panel.grid.minor = element_blank())
```

In the plots above, any method that appeared less then 5% of the time was lumped into "other", and in the table below, we show all methods, sorted by occurrence. In the table below, we preserve all categories for review.

```{r}
jc %>% 
  # anything that appears less then 5% of the time is lumped into "other"
  mutate(echo_geocode_method = fct_lump_prop(echo_geocode_method, 0.05)) %>%
  group_by(primacy_agency_code, echo_geocode_method) %>% 
  summarise(n = n()) %>% 
  mutate(p = round(n / sum(n)*100, 2)) %>% 
  ungroup() %>% 
  arrange(primacy_agency_code, desc(p)) %>% 
  dt_make()
```


<br>  

### Centroid coverage at PWSIDs with unlabeled spatial data

Centroid accuracy is more important for _unlabeled systems that we do not have explicit boundary polygons for, or that we cannot assign to a TIGRIS proxy polygon_. This is because- where no spatial boundary exists- the centroid will be the basis for an estimated water service boundary. We will model a radius from this centroid to approximate a service area. Thus, we now recalculate missingness for the subset of data **without** an existing spatial boundary and without a matching TIGER/Line place using the same two plots and table in the previous section.

In our current attempt to match community water systems to TIGER/Line place polygons, which can serve as an estimated water service boundary, we achieve a `r round((nrow(filter(jc, !is.na(tigris_match_geoid)))/nrow(jc))*100, 2)`% match rate. We are continuing to improve our matching approach and expect this number to grow. Currently we are only looking at name matches for systems whose ECHO lat/long centroid falls within a TIGER/Line polygon, but we will expand this to simply match on names in a future iteration.

```{r}
# states where we have labeled spatial data
states_labeled <- unique(wsb_labeled_simp$state) %>% discard(is.na)
  
jc %>% 
  # remove all pwsids that match to a TIGER/Line proxy polygon or labeled state
  filter(is.na(tigris_match_geoid)) %>% 
  filter(! primacy_agency_code %in% states_labeled) %>% 
  # anything that appears less then 5% of the time is lumped into "other"
  mutate(echo_geocode_method = fct_lump_prop(echo_geocode_method, 0.05)) %>%
  group_by(echo_geocode_method) %>% 
  summarise(n = n()) %>% 
  ungroup() %>% 
  mutate(
    p = n/sum(n),
    echo_geocode_method = case_when(
    echo_geocode_method == "ADDRESS MATCHING-HOUSE NUMBER" ~ "address match",
    echo_geocode_method == "INTERPOLATION-PHOTO"           ~ "interp photo",
    echo_geocode_method == "County Centroid"               ~ "centroid county",
    echo_geocode_method == "State Centroid"                ~ "centroid state",
    echo_geocode_method == "Zip Code Centroid"             ~ "centroid zip",
    echo_geocode_method == "Other"                         ~ "other",
    TRUE ~ NA_character_
  )) %>% 
  ggplot(aes(fct_reorder(echo_geocode_method, p), p, 
             fill = echo_geocode_method)) + 
  geom_col() + 
  coord_flip() +
  scale_fill_carto_d() +
  scale_y_continuous(limits = c(0, 1)) +
  theme_minimal() +
  theme(panel.grid.minor = element_blank()) +
  labs(x = "", y = "Count", title = "ECHO geocoding method",  subtitle = "Water systems with *no* labeled spatial data.") +
  guides(fill = "none")

# summary proportion of geocoding method by state
jcs2 <- jc %>% 
  # remove all pwsids that match to a TIGER/Line proxy polygon or labeled state
  filter(is.na(tigris_match_geoid)) %>% 
  filter(! primacy_agency_code %in% states_labeled) %>% 
  # anything that appears less then 5% of the time is lumped into "other"
  mutate(echo_geocode_method = fct_lump_prop(echo_geocode_method, 0.05)) %>%
  group_by(primacy_agency_code, echo_geocode_method) %>% 
  summarise(n = n()) %>% 
  mutate(p = n / sum(n)) %>% 
  mutate(echo_geocode_method = case_when(
    echo_geocode_method == "ADDRESS MATCHING-HOUSE NUMBER" ~ "address match",
    echo_geocode_method == "INTERPOLATION-PHOTO"           ~ "interp photo",
    echo_geocode_method == "County Centroid"               ~ "centroid county",
    echo_geocode_method == "State Centroid"                ~ "centroid state",
    echo_geocode_method == "Zip Code Centroid"             ~ "centroid zip",
    echo_geocode_method == "Other"                         ~ "other",
    TRUE ~ NA_character_
  )) %>% 
  ungroup()
```


In the plot below, note that blank states are those for which we have labeled data. States with results only show water systems without a matching TIGER/Line place proxy polygon. 

```{r}
# plot
jcs2 %>% 
  filter(!is.na(primacy_agency_code)) %>% 
  ggplot(aes(fct_reorder(echo_geocode_method, p), p, 
             fill = echo_geocode_method)) + 
  geom_col() + 
  coord_flip() +
  scale_fill_carto_d() +
  scale_y_continuous(breaks = c(0, 0.5, 1),
                     labels = c(0, 0.5, 1),
                     limits = c(0, 1)) +
  geofacet::facet_geo(~primacy_agency_code) +
  labs(x = "", y = "Proportion", 
       title = "ECHO geocoding method", subtitle = "Water systems by state with *no* labeled spatial data.") +
  guides(fill = "none") +
  theme_minimal(base_size = 6) +
  theme(panel.grid.minor = element_blank())

# datatable
jc %>% 
  # remove all pwsids that match to a tigris proxy polygon or labeled state
  filter(is.na(tigris_match_geoid)) %>% 
  filter(! primacy_agency_code %in% states_labeled) %>% 
  # anything that appears less then 5% of the time is lumped into "other"
  mutate(echo_geocode_method = fct_lump_prop(echo_geocode_method, 0.05)) %>%
  group_by(primacy_agency_code, echo_geocode_method) %>% 
  summarise(n = n()) %>% 
  mutate(p = round(n / sum(n)*100,2)) %>% 
  ungroup() %>% 
  arrange(primacy_agency_code, desc(p)) %>% 
  dt_make()
```


> **RECCOMENDATION**: Results suggest different approaches to centroid estimation across states and some approaches are more accurate than others. Moreover, centroid accuracy is most important for _unlabeled_ data, and for these data, county centroids account for half of centroid locations--improvement is needed in these centroid estimates to better "center" service boundary predictions. We advise creation of a supplementary table with two columns (`echo_geocode_method` and `valid`) where each row is a unique centroid geocoding method. The `valid` column should be a boolean (`TRUE/FALSE`) that designates if we wish to "trust" and retain this information. A rule of thumb may be if we have reason to believe that the approach is less accurate than the zip code centroid. For methods where `valid == FALSE`, we should then re-estimate centroids as zip code centroids (if we can obtain zip codes). 


<br>  

## Tabular data missingness

"Tabular data" refers to any data attached to PWSIDs (e.g., population served, system size) in various federal databases (e.g., FRS, ECHO, and so on). These tabular data are the independent variables on which we will train statistical and machine learning models to predict water service boundaries for unlabeled data, thus it is critical that they are present across the dataset^[Tabular data missingness may be addressed in a number of imputation methods, but importantly, these methods are not as accurate as a complete dataset to begin with.]. 

`r nrow(filter(j, is.na(population_served_count))) / nrow(j)`% of PWSIDs are missing "population served", and `r round((nrow(filter(j, is.na(service_connections_count))) / nrow(j))*100, 2)`% of PWSIDs are missing "service connection count". We expect these two variables to be important in predicting unlabeled water service boundary radii, hence, we assess their missingness here. As we identify additional features to train models on, we will assess their missingness and update this report. 


<br>  

### System size (i.e., connection count) and population served

As thes variables relate to one another (we expect a lienar correlation), they are examined together. `r nrow(filter(j, is.na(service_connections_count))) / nrow(j)`% of PWSIDs are missing "system size" and `r nrow(filter(j, is.na(population_served_count))) / nrow(j)`% of PWSIDs are missing "population served", although some of these values are equal to zero and likely incorrect, which we explore later in this section. 

We classify water service areas by size consistent with [EPA guidelines](https://echo.epa.gov/help/drinking-water-dashboard-help#:~:text=Very%20Small%20%C2%A0%20%C2%A0%20%C2%A0%20500,Very%20Large%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%3E100%2C000):  
 
 
| EPA classification | Connection count    |
|--------------------|---------------------|
| Very Small         |  500 or less        |
| Small              |  501 - 3,300        |
| Medium             |  3,301 - 10,000     |
| Large              |  10,001 - 100,000   |  
| Very Large         |  >100,000           |

According to the [EPA](https://echo.epa.gov/help/drinking-water-dashboard-help#:~:text=Small%20and%20very%20small%20PWSs%20comprise%20the,source%2C%20such%20as%20a%20drinking%20water%20well.), "small and very small PWSs comprise the approximately 95% of all PWSs, but they serve just 12 percent of all consumers. Small PWSs include both community and non-community water systems. Some examples of non-community systems include office buildings, schools, campgrounds, or highway rest stops with their own water source, such as a drinking water well."

Service connection count ranges from 0 (`r nrow(filter(j, service_connections_count == 0))` PWSIDs) to 
approximately 1 million (New York City, NY7003493). Within size classes, service connection count shows approximately log-2 scaling, with a the tail of the distribution about falling around twice the mean value. Very Small and Small systems account for 92% of CWSs, which is consistent with EPA's findings (95%). In the plot below, note the different x and y scales. 

```{r}
# add water system size to the "incomplete" joined data (2k/55k without lat/lng) joined data
size_lvls <- c("Very Small", "Small", "Medium", "Large", "Very Large")

j <- j %>% 
  mutate(
    size_class = case_when(
      service_connections_count <= 500 ~ "Very Small",
      service_connections_count > 500 & service_connections_count <= 3300 ~ "Small",
      service_connections_count > 3300 & service_connections_count <= 10000 ~ "Medium",
      service_connections_count > 10000 & service_connections_count <= 100000 ~ "Large",
      service_connections_count > 100000 ~ "Very Large"),
    size_class = factor(size_class, levels = size_lvls)
  )
  
# annotation text and line to highlight NYC
ann_text <- tibble(
  label = "New York City",
  size_class = factor("Very Large", levels = size_lvls)
)

ann_line <- tibble(
  xmin = 8e5, xmax = 9.35e5, ymin = 10, ymax = 2,
  size_class = factor("Very Large", levels = size_lvls)
)

# plot
j %>% 
  ggplot(aes(service_connections_count, fill = size_class)) + 
  geom_histogram(color = "white", lwd = 0.2) +
  geom_text(
    data    = ann_text,
    mapping = aes(x = 6e5, y = 13, label = label)
  ) +
  geom_segment(
    data = ann_line,
    aes(x = xmin, xend = xmax, y = ymin, yend = ymax),
    arrow = arrow(length = unit(0.2, "cm"))) +
  scale_fill_carto_d() +
  scale_x_continuous(label = scales::comma) +
  scale_y_continuous(label = scales::comma) +
  facet_wrap(~size_class, scales = "free", ncol = 2) +
  labs(x = "Service Connection count", y = "Count") +
  theme_minimal() +
  theme(panel.grid.minor = element_blank()) +
  guides(fill = "none")
```

```{r}
j %>% 
  count(size_class) %>% 
  mutate(proportion = round(n/sum(n), 2)) %>% 
  dt_make()
```


Although no population count or service connection count is missing, there are zeroes in some of these data fields which may indicate faulty data. Importantly, zeroes are not "completely at random", and show higher frequency in states like SC, which further suggests faultiness. 


#### zero service connections

`r round((nrow(filter(j, service_connections_count == 0))/nrow(j))*100, 2)`% of PWSIDs have 0 population served, which is unlikely to be true and primarily impacts SC. We may drop these, or impute a population equal to the mean population for the reported system size if present. 

```{r}
zero_sc <- filter(j, service_connections_count == 0) 

zero_sc %>%   
  # rm column created on suspect data
  select(-size_class) %>% 
  # only show certain cols in DT
  select(pwsid, pws_name, pop_count = population_served_count, 
         con_count = service_connections_count, 
         tigris = tigris_match_geoid) %>% 
  dt_make()

zero_sc %>% 
  count(primacy_agency_code, sort = TRUE, name = "n_missing") %>% 
  knitr::kable()
```

#### zero population count

`r round((nrow(filter(j, population_served_count == 0))/nrow(j))*100, 2)`% of PWSIDs have 0 population served, which is unlikely to be true and primarily impacts TX, CA, SC, CO, and ME. We may drop these, or impute a population equal to the mean population for the reported system size (if present). 

```{r}
zero_pop <- filter(j, population_served_count == 0) 

zero_pop %>%   
  # rm column created on suspect data
  select(-size_class) %>% 
  # only show certain cols in DT
  select(pwsid, pws_name, pop_count = population_served_count, 
         con_count = service_connections_count, 
         tigris = tigris_match_geoid) %>% 
  dt_make()

zero_pop %>% 
  count(primacy_agency_code, sort = TRUE, name = "n_missing") %>% 
  knitr::kable()
```



#### zero service connections AND zero population served

- `r round((nrow(filter(j, service_connections_count == 0 & population_served_count == 0))/nrow(j))*100, 2)`% of PWSIDs have 0 population served **AND** 0 service connection count. These primarily impact 

```{r}
zero_sc_pop <- filter(j, service_connections_count == 0 & 
                        population_served_count == 0)

zero_sc_pop %>% 
  # rm column created on suspect data
  select(-size_class) %>% 
  # only show certain cols in DT
  select(pwsid, pws_name, pop_count = population_served_count, 
         con_count = service_connections_count, 
         tigris = tigris_match_geoid) %>% 
  dt_make()

zero_sc_pop %>% 
  count(primacy_agency_code, sort = TRUE, name = "n_missing") %>% 
  knitr::kable()
```


#### zero service connections OR zero population served

- `r round((nrow(filter(j, service_connections_count == 0 | population_served_count == 0))/nrow(j))*100, 2)`% of PWSIDs have 0 population served **OR** 0 service connection count. These strongly indicate faulty data: how can non-zero service connections indicate zero population, or vice versa? TX, CA, SC, and CO are among the chief offenders, although we expect more faulty data for large states like CA and TX, but not as much for a small state like SC.

```{r}
zero_sc_or_pop <- filter(j, service_connections_count == 0 | 
                        population_served_count == 0)

zero_sc_or_pop %>% 
  # rm column created on suspect data
  select(-size_class) %>% 
  # only show certain cols in DT
  select(pwsid, pws_name, pop_count = population_served_count, 
         con_count = service_connections_count, 
         tigris = tigris_match_geoid) %>% 
  dt_make()

zero_sc_or_pop %>% 
  count(primacy_agency_code, sort = TRUE, name = "n_missing") %>% 
  knitr::kable()
```


> **RECOMMENDATION**: Results suggest around 5% of data is missing either a population served or system size. More often than not, the population served is missing. This may be "mean imputed" from systems of similar size, as population served and service connection count shows a strong linear relationship^[This plot shows other potentially faulty data, for instance, a high leverage point on the x-axis with a population served of 2.5 million, but a very small nonzero service connection count. Similarly, another data point on the y axis has a ~700,000 service connections but serves a very small nonzero population. Outliers outside of, say, 2 or 3SD from the linear model may be discarded from the model, or we may individually clean data, particularly where incorrect data will yield unreasonable predicted boundaries.]: 

```{r}
j %>% 
  # remove the rows we propose imputing
  filter(population_served_count > 0 & service_connections_count > 0) %>% 
  # remove nnew york city which exerts excessive leverage
  filter(pwsid != "NY7003493") %>% 
  ggplot(aes(population_served_count, service_connections_count)) +
  geom_point(alpha = 0.5) + 
  geom_smooth(method = "lm") +
  theme_minimal() +
  theme(panel.grid.minor = element_blank())
```

<br>  


# Data Quality


# Coverage relative to SDWIS master list of active, community water systems
It is helpful to look at coverage disaggregated by different system categories. 

```{r, echo=FALSE}
# get list of pwsid with boundaries
pwsid_bnd <- wsb_labeled_simp %>% 
  select(pwsid) %>%
  st_drop_geometry()

# create boolean for full sdwis dataset, now we have information about boundaries,
# TIGER/Line shapefiles, and centroids
jb <- j %>%
  mutate(wsb = ifelse(pwsid %in% pwsid_bnd$pwsid, TRUE, FALSE),
         tigris = ifelse(!is.na(tigris_match_geoid), TRUE, FALSE),
         echo = ifelse(!is.na(echo_latitude), TRUE, FALSE))

```

We currently have coverage in the current set of service boundaries for `r round((nrow(filter(jb, tigris == TRUE | wsb == TRUE)) / nrow(jb))*100, 2)`% of community water systems. Interestingly, there is only `r round((nrow(filter(jb, tigris == TRUE & wsb == TRUE)) / nrow(jb))*100, 2)`% of systems that have _both_ water service boundaries _and_ TIGER/Line shapefile boundaries according to our current list. Of the public water systems that have an established or potential polygon from TIGER/Line shapefiles, they serve `r jb %>% filter(tigris == TRUE | wsb == TRUE) %>% summarise(pop_sum = sum(population_served_count, na.rm=TRUE))` people.

The objective of this section is to look at the coverage across boundary types by key variables of concern, e.g. system size, ownership type, whether a system is serving a tribal area or not, and overall population coverage. We cover:

- Summary of existing boundary coverage by system size (using [EPA categories](https://echo.epa.gov/help/drinking-water-dashboard-help))  
- Summary of existing boundary coverage by system type (Municipal, etc) / ownership type  
- Summary of existing boundary coverage by tribal vs non-tribal (i.e. primacy_type_code is territory?)  
- Total US population served by existing boundary date (using SDWIS provided `population_served`)  


### System size
```{r}

# summary of existing geometry types by system size
jb %>% 
  select(size_class, wsb, tigris, echo) %>%
  gather(-size_class, key = "geom_type", value = "indicator") %>%
  ggplot(aes(size_class, fill = indicator)) + 
  geom_bar(color = "white", lwd = 0.2, show.legend = TRUE) +
  scale_color_manual(values = c("red", "blue")) +
  facet_wrap(~geom_type, scales = "free", ncol = 2) +
  labs(x = "System Size", y = "Count") +
  theme_minimal() +
  ggtitle("Geometry type availability by system size") +
  theme(panel.grid.minor = element_blank(), legend.position = "top")

# table indicating presence/absence of boundary by geometry type and owner type
jb %>% 
  select(size_class, wsb, tigris, echo) %>%
  gather(-size_class, key = "geom_type", value = "indicator") %>%
  group_by(size_class, geom_type, indicator) %>%
  summarize(n = n())

  
```
Preliminary conclusions: large systems appear to have the biggest proportion of coverage for TIGER/Line shapefiles and labeled data relative to the total number of systems. It appears that very small, small, and medium systems  have a higher proportion of unknown boundaries, and less TIGER/Line shapefile coverage, relative to their overall counts.

### Ownership type

```{r}

# summary of existing geometry types by owner type
jb %>% 
  select(owner_type_code, wsb, tigris, echo) %>%
  gather(-owner_type_code, key = "geom_type", value = "indicator") %>%
  group_by(owner_type_code, geom_type) %>%
  ggplot(aes(owner_type_code, fill = indicator)) + 
  geom_bar(color = "white", lwd = 0.2, show.legend = TRUE) +
  scale_color_manual(values = c("red", "blue")) +
  facet_wrap(~geom_type, scales = "free", ncol = 2) +
  labs(x = "Geometry Type", y = "Count") +
  theme_minimal() +
  theme(panel.grid.minor = element_blank()) +
  ggtitle("Geometry type availability by ownership type") +
  theme(panel.grid.minor = element_blank(), legend.position = "top")

# table indicating presence/absence of boundary by geometry type and owner type
jb %>% 
  select(owner_type_code, wsb, tigris, echo) %>%
  gather(-owner_type_code, key = "geom_type", value = "indicator") %>%
  group_by(owner_type_code, geom_type, indicator) %>%
  summarize(n = n()) %>%
  distinct()

  
```
Preliminary conclusions: Systems with boundaries and/or TIGRER/Line shapefiles are largely local or privately owned systems, according to this classification. More work should be done to understand if all municipal types are under local ownership in sdwis, and why more of them are not matching to TIGER/Line shapefiles.

### Territory vs State

```{r}

# summary of existing geometry types by FRS / ECHO flag
jb %>% 
  filter(!is.na(fac_indian_cntry_flg)) %>%
  select(fac_indian_cntry_flg, wsb, tigris, echo) %>%
  gather(-fac_indian_cntry_flg, key = "geom_type", value = "indicator") %>%
  group_by(fac_indian_cntry_flg, geom_type) %>%
  ggplot(aes(fac_indian_cntry_flg, fill = indicator)) + 
  geom_bar(color = "white", lwd = 0.2, show.legend = TRUE) +
  scale_color_manual(values = c("red", "blue")) +
  facet_wrap(~geom_type, scales = "free", ncol = 2) +
  labs(x = "Tribal/Native Territory (True/False)", y = "Count") +
  theme_minimal() +
  theme(panel.grid.minor = element_blank()) +
  ggtitle("Geometry type availability by systems within Native American tribal boundary", 
          subtitle = "Based on indicator from EPA") +
  theme(panel.grid.minor = element_blank(), legend.position = "top")

# table indicating presence/absence of boundary by geometry type and tribal boundary flag
jb %>% 
  select(in_tribal_boundary = fac_indian_cntry_flg, wsb, tigris, echo) %>%
  gather(-in_tribal_boundary, key = "geom_type", value = "indicator") %>%
  group_by(in_tribal_boundary, geom_type, indicator) %>%
  summarize(n = n()) %>%
  distinct()

  
```

### Population coverage by geometry type

To identify areas with the most types of coverage, we can look at population served by different geometry types, also by state. 

```{r}

# simplified overall population coverage by geometry type

jb %>% 
  filter(!is.na(primacy_agency_code)) %>% 
  select(population_served_count, wsb, tigris, echo) %>%
  gather(-population_served_count, key = "geom_type", value = "indicator") %>%
  ggplot(aes(population_served_count, geom_type,
             fill = indicator)) + 
  geom_col(show.legend = TRUE) + 
  coord_flip() +
  scale_fill_carto_d() +
  theme_minimal() +
  theme(panel.grid.minor = element_blank()) +
  ggtitle("Population served by geometry coverage type") +
  theme(panel.grid.minor = element_blank(), legend.position = "top")

# More complex, this same breakdown by state

jb %>% 
  filter(!is.na(primacy_agency_code)) %>% 
  select(primacy_agency_code, population_served_count, wsb, tigris, echo) %>%
  gather(-primacy_agency_code, -population_served_count, key = "geom_type", value = "indicator") %>%
  ggplot(aes(population_served_count, geom_type,
             fill = indicator)) + 
  geom_col(show.legend = TRUE) + 
  coord_flip() +
  scale_fill_carto_d() +
  geofacet::facet_geo(~primacy_agency_code) +
  theme_minimal() +
  theme(panel.grid.minor = element_blank()) +
  ggtitle("Population served by geometry coverage type") +
  theme(panel.grid.minor = element_blank(), legend.position = "top")


```

# Recommendations and next steps
